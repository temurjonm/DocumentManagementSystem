import { SQSClient, ReceiveMessageCommand, DeleteMessageCommand } from '@aws-sdk/client-sqs';
import { S3Client, GetObjectCommand } from '@aws-sdk/client-s3';
import { SFNClient, SendTaskSuccessCommand, SendTaskFailureCommand } from '@aws-sdk/client-sfn';
import { createWriteStream, unlinkSync } from 'fs';
import { exec } from 'child_process';
import { promisify } from 'util';
import { pipeline } from 'stream/promises';
import { logger } from '../shared/logger';

const execAsync = promisify(exec);

const sqs = new SQSClient({ region: process.env.AWS_REGION });
const s3 = new S3Client({ region: process.env.AWS_REGION });
const sfn = new SFNClient({ region: process.env.AWS_REGION });

const QUEUE_URL = process.env.QUEUE_URL!;
const S3_BUCKET = process.env.S3_BUCKET!;

interface ScanMessage {
  documentId: string;
  versionId: string;
  s3Bucket: string;
  s3Key: string;
  taskToken: string;
}

async function downloadFile(s3Key: string, localPath: string): Promise<void> {
  const response = await s3.send(
    new GetObjectCommand({
      Bucket: S3_BUCKET,
      Key: s3Key,
    })
  );

  if (!response.Body) {
    throw new Error('Empty S3 response body');
  }

  const writeStream = createWriteStream(localPath);
  await pipeline(response.Body as NodeJS.ReadableStream, writeStream);
}

async function scanFile(filePath: string): Promise<{ clean: boolean; threat?: string }> {
  try {
    await execAsync(`clamscan --no-summary ${filePath}`);
    return { clean: true };
  } catch (error: any) {
    const output = error.stdout || error.stderr || '';
    
    if (output.includes('FOUND')) {
      const threatMatch = output.match(/(.+): (.+) FOUND/);
      const threat = threatMatch ? threatMatch[2] : 'Unknown threat';
      return { clean: false, threat };
    }
    
    throw error;
  }
}

async function processMessage(message: ScanMessage): Promise<void> {
  const { documentId, versionId, s3Key, taskToken } = message;
  
  logger.setContext({ documentId, versionId });
  logger.info('Processing malware scan', { s3Key });

  const localPath = `/tmp/${documentId}-${versionId}`;

  try {
    await downloadFile(s3Key, localPath);
    logger.info('File downloaded for scanning');

    const scanResult = await scanFile(localPath);
    
    if (scanResult.clean) {
      logger.info('File is clean');
      
      await sfn.send(
        new SendTaskSuccessCommand({
          taskToken,
          output: JSON.stringify({
            documentId,
            versionId,
            scanResult: 'CLEAN',
          }),
        })
      );
    } else {
      logger.warn('Malware detected', { threat: scanResult.threat });
      
      await sfn.send(
        new SendTaskFailureCommand({
          taskToken,
          error: 'MalwareDetected',
          cause: `Malware detected: ${scanResult.threat}`,
        })
      );
    }
  } catch (error) {
    logger.error('Malware scan failed', error as Error);
    
    await sfn.send(
      new SendTaskFailureCommand({
        taskToken,
        error: 'ScanError',
        cause: error instanceof Error ? error.message : 'Unknown error',
      })
    );
    
    throw error;
  } finally {
    try {
      unlinkSync(localPath);
    } catch (err) {
      logger.warn('Failed to delete temp file', { localPath });
    }
    logger.clearContext();
  }
}

async function pollQueue(): Promise<void> {
  logger.info('Starting malware scan worker');

  while (true) {
    try {
      const response = await sqs.send(
        new ReceiveMessageCommand({
          QueueUrl: QUEUE_URL,
          MaxNumberOfMessages: 1,
          WaitTimeSeconds: 20,
          VisibilityTimeout: 3600,
        })
      );

      if (!response.Messages || response.Messages.length === 0) {
        continue;
      }

      for (const sqsMessage of response.Messages) {
        if (!sqsMessage.Body || !sqsMessage.ReceiptHandle) {
          continue;
        }

        const message: ScanMessage = JSON.parse(sqsMessage.Body);
        
        await processMessage(message);
        
        await sqs.send(
          new DeleteMessageCommand({
            QueueUrl: QUEUE_URL,
            ReceiptHandle: sqsMessage.ReceiptHandle,
          })
        );
      }
    } catch (error) {
      logger.error('Error polling queue', error as Error);
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
  }
}

if (require.main === module) {
  pollQueue().catch(error => {
    logger.error('Worker crashed', error as Error);
    process.exit(1);
  });
}

export { processMessage, scanFile };
