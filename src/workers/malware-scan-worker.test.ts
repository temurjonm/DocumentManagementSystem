import { S3Client } from '@aws-sdk/client-s3';
import { SFNClient } from '@aws-sdk/client-sfn';
import { Readable } from 'stream';
import { unlinkSync, createWriteStream } from 'fs';

jest.mock('@aws-sdk/client-s3');
jest.mock('@aws-sdk/client-sfn');
jest.mock('child_process', () => ({
  exec: jest.fn(),
}));
jest.mock('fs');
jest.mock('util', () => ({
  promisify: (fn: any) => fn,
}));
jest.mock('stream/promises', () => ({
  pipeline: jest.fn(),
}));
jest.mock('../shared/logger', () => ({
  logger: {
    setContext: jest.fn(),
    clearContext: jest.fn(),
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
  },
}));

const mockS3Send = jest.fn();
const mockSFNSend = jest.fn();
const mockExec = require('child_process').exec as jest.Mock;
const mockUnlinkSync = unlinkSync as jest.MockedFunction<typeof unlinkSync>;
const mockCreateWriteStream = createWriteStream as jest.MockedFunction<typeof createWriteStream>;
const mockPipeline = require('stream/promises').pipeline as jest.Mock;

(S3Client as jest.Mock).mockImplementation(() => ({
  send: mockS3Send,
}));

(SFNClient as jest.Mock).mockImplementation(() => ({
  send: mockSFNSend,
}));

import { processMessage, scanFile } from './malware-scan-worker';

describe('Malware Scan Worker', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    process.env.S3_BUCKET = 'test-bucket';
    process.env.AWS_REGION = 'us-east-1';
  });

  describe('scanFile', () => {
    it('should detect infected files and return threat information', async () => {
      // Mock clamscan detecting malware
      const mockError = new Error('Command failed') as any;
      mockError.stdout = '/tmp/test-file: Win.Test.EICAR_HDB-1 FOUND';
      mockError.stderr = '';
      mockExec.mockRejectedValue(mockError);

      const result = await scanFile('/tmp/test-file');

      expect(result.clean).toBe(false);
      expect(result.threat).toBe('Win.Test.EICAR_HDB-1');
      expect(mockExec).toHaveBeenCalledWith('clamscan --no-summary /tmp/test-file');
    });

    it('should return clean status for non-infected files', async () => {
      // Mock clamscan returning success (no malware)
      mockExec.mockResolvedValue({ stdout: '', stderr: '' });

      const result = await scanFile('/tmp/clean-file');

      expect(result.clean).toBe(true);
      expect(result.threat).toBeUndefined();
    });

    it('should handle unknown threats', async () => {
      // Mock clamscan detecting malware without proper format
      const mockError = new Error('Command failed') as any;
      mockError.stdout = 'Something FOUND but no match';
      mockError.stderr = '';
      mockExec.mockRejectedValue(mockError);

      const result = await scanFile('/tmp/test-file');

      expect(result.clean).toBe(false);
      expect(result.threat).toBe('Unknown threat');
    });

    it('should throw error for scan failures', async () => {
      // Mock clamscan failing without FOUND in output
      const mockError = new Error('Scanner error') as any;
      mockError.stdout = '';
      mockError.stderr = 'Scanner crashed';
      mockExec.mockRejectedValue(mockError);

      await expect(scanFile('/tmp/test-file')).rejects.toThrow();
    });
  });

  describe('processMessage', () => {
    const mockMessage = {
      documentId: 'doc-123',
      versionId: 'ver-456',
      s3Bucket: 'test-bucket',
      s3Key: 'tenant-1/documents/doc-123/ver-456/original.pdf',
      taskToken: 'task-token-789',
    };

    beforeEach(() => {
      // Mock S3 download - return proper response structure
      const mockStream = Readable.from(['file content']);
      mockS3Send.mockResolvedValue({
        Body: mockStream,
      });

      // Mock pipeline for stream processing
      mockPipeline.mockResolvedValue(undefined);

      // Mock file write stream
      const mockWriteStream: any = {
        write: jest.fn(),
        end: jest.fn(),
        on: jest.fn((event: string, handler: () => void) => {
          if (event === 'finish') {
            setTimeout(handler, 0);
          }
          return mockWriteStream;
        }),
      };
      mockCreateWriteStream.mockReturnValue(mockWriteStream);

      // Mock unlinkSync to not throw
      mockUnlinkSync.mockImplementation(() => {});
    });

    it('should send success when file is clean', async () => {
      // Mock clean scan result
      mockExec.mockResolvedValue({ stdout: '', stderr: '' });

      await processMessage(mockMessage);

      // Verify S3 download was called
      expect(mockS3Send).toHaveBeenCalled();

      // Verify Step Functions success was sent
      expect(mockSFNSend).toHaveBeenCalled();
      
      // Verify the command was called (we can't easily inspect the command input)
      expect(mockSFNSend).toHaveBeenCalledTimes(1);

      expect(mockUnlinkSync).toHaveBeenCalled();
    });

    it('should send failure when malware is detected', async () => {
      // Mock infected file
      const mockError = new Error('Command failed') as any;
      mockError.stdout = '/tmp/file: Win.Test.EICAR_HDB-1 FOUND';
      mockError.stderr = '';
      mockExec.mockRejectedValue(mockError);

      await processMessage(mockMessage);

      // Verify Step Functions failure was sent
      expect(mockSFNSend).toHaveBeenCalled();
      expect(mockSFNSend).toHaveBeenCalledTimes(1);

      expect(mockUnlinkSync).toHaveBeenCalled();
    });

    it('should send failure when scan errors occur', async () => {
      // Mock scan error
      const mockError = new Error('Scanner crashed');
      mockExec.mockRejectedValue(mockError);

      await expect(processMessage(mockMessage)).rejects.toThrow('Scanner crashed');

      // Verify Step Functions failure was sent
      expect(mockSFNSend).toHaveBeenCalled();
      expect(mockSFNSend).toHaveBeenCalledTimes(1);

      expect(mockUnlinkSync).toHaveBeenCalled();
    });

    it('should clean up temp file even on failure', async () => {
      // Mock scan error
      mockExec.mockRejectedValue(new Error('Test error'));

      await expect(processMessage(mockMessage)).rejects.toThrow();

      expect(mockUnlinkSync).toHaveBeenCalled();
    });
  });
});
